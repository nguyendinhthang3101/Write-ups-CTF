# Base64
challenge này cho một file ``base64.py``
```python
b64 = {
    "000000": "/",
    "000001": "+",
    "000010": "0",
    "000011": "1",
    "000100": "2",
    "000101": "3",
    "000110": "4",
    "000111": "5",
    "001000": "6",
    "001001": "7",
    "001010": "8",
    "001011": "9",
    "001100": "a",
    "001101": "b",
    "001110": "c",
    "001111": "d",
    "010000": "e",
    "010001": "f",
    "010010": "g",
    "010011": "h",
    "010100": "i",
    "010101": "j",
    "010110": "k",
    "010111": "l",
    "011000": "m",
    "011001": "n",
    "011010": "o",
    "011011": "p",
    "011100": "q",
    "011101": "r",
    "011110": "s",
    "011111": "t",
    "100000": "u",
    "100001": "v",
    "100010": "w",
    "100011": "x",
    "100100": "y",
    "100101": "z",
    "100110": "A",
    "100111": "B",
    "101000": "C",
    "101001": "D",
    "101010": "E",
    "101011": "F",
    "101100": "G",
    "101101": "H",
    "101110": "I",
    "101111": "J",
    "110000": "K",
    "110001": "L",
    "110010": "M",
    "110011": "N",
    "110100": "O",
    "110101": "P",
    "110110": "Q",
    "110111": "R",
    "111000": "S",
    "111001": "T",
    "111010": "U",
    "111011": "V",
    "111100": "W",
    "111101": "X",
    "111110": "Y",
    "111111": "Z",
}
 
 
def encode(string):
    s = ""
    for i in string:
        s += bin(ord(i))[2:].zfill(8)
     
    pad = ""
    if len(s) % 6 == 4:
        pad = "="
        s += "11"
    elif len(s) % 6 == 2:
        pad = "=="
        s += "1111"
     
    ret = ""
    for i in range(0,len(s),6):
        ret += b64[s[i:i+6]]
    return ret+pad
 
from secret import FLAG
print(encode(FLAG))
 
# gOP+sRaKphbtmRjNr1+HlObgkl+Oa5R=
```
Đọc source code thì mình biết đây là cách encode từ text sang base64. Cụ thể như sau:

- Từ một đoạn text bình thường, ta lấy giá trị của kí tự tra trong bảng mã ASCII theo hệ cơ số 10 và chuyển nó về nhị phân với đủ 8 bit

- Sau đó nối các bit nhị phân này lại theo thứ tự của text

- Từ chuỗi nhị phân trên ta lấy lần lượt từng 6 bit và chuyển nó về decimal rồi đối chiếu số đó với một bảng riêng của Base64

- Và cứ thế ta thu được đoạn Base64 tương ứng với text ban đầu

Trong source code challenge này tác giả dùng bảng convert Base64 đã được chỉnh sửa khác với Base64 được dùng phổ biến bằng một dictionary ``b64``

Về cách decode thì ta làm ngược lại… viết một dictionary khác là đảo ngược của dictionary b64 nhưng mà chú ý đến dấu '=' tương ứng với bit 11

dictionary đảo ngược của dictionary b64:

```python
b64 = {
    "000000": "/",
    "000001": "+",
    "000010": "0",
    "000011": "1",
    "000100": "2",
    "000101": "3",
    "000110": "4",
    "000111": "5",
    "001000": "6",
    "001001": "7",
    "001010": "8",
    "001011": "9",
    "001100": "a",
    "001101": "b",
    "001110": "c",
    "001111": "d",
    "010000": "e",
    "010001": "f",
    "010010": "g",
    "010011": "h",
    "010100": "i",
    "010101": "j",
    "010110": "k",
    "010111": "l",
    "011000": "m",
    "011001": "n",
    "011010": "o",
    "011011": "p",
    "011100": "q",
    "011101": "r",
    "011110": "s",
    "011111": "t",
    "100000": "u",
    "100001": "v",
    "100010": "w",
    "100011": "x",
    "100100": "y",
    "100101": "z",
    "100110": "A",
    "100111": "B",
    "101000": "C",
    "101001": "D",
    "101010": "E",
    "101011": "F",
    "101100": "G",
    "101101": "H",
    "101110": "I",
    "101111": "J",
    "110000": "K",
    "110001": "L",
    "110010": "M",
    "110011": "N",
    "110100": "O",
    "110101": "P",
    "110110": "Q",
    "110111": "R",
    "111000": "S",
    "111001": "T",
    "111010": "U",
    "111011": "V",
    "111100": "W",
    "111101": "X",
    "111110": "Y",
    "111111": "Z",
}
decode_b64={}
for i in b64:
    temp={b64[i]:i}
    decode_b64.update(temp)
```
Đảo ngược xong rồi thì ta chuyển nó về binary theo dictionary decode_b64 ở trên và rồi lấy từng 8 bit chuyển sang decimal và đưa về kí tự trong bảng mã ASCII tương ứng

``base64_solve.py``

```python3
b64 = {
    "000000": "/",
    "000001": "+",
    "000010": "0",
    "000011": "1",
    "000100": "2",
    "000101": "3",
    "000110": "4",
    "000111": "5",
    "001000": "6",
    "001001": "7",
    "001010": "8",
    "001011": "9",
    "001100": "a",
    "001101": "b",
    "001110": "c",
    "001111": "d",
    "010000": "e",
    "010001": "f",
    "010010": "g",
    "010011": "h",
    "010100": "i",
    "010101": "j",
    "010110": "k",
    "010111": "l",
    "011000": "m",
    "011001": "n",
    "011010": "o",
    "011011": "p",
    "011100": "q",
    "011101": "r",
    "011110": "s",
    "011111": "t",
    "100000": "u",
    "100001": "v",
    "100010": "w",
    "100011": "x",
    "100100": "y",
    "100101": "z",
    "100110": "A",
    "100111": "B",
    "101000": "C",
    "101001": "D",
    "101010": "E",
    "101011": "F",
    "101100": "G",
    "101101": "H",
    "101110": "I",
    "101111": "J",
    "110000": "K",
    "110001": "L",
    "110010": "M",
    "110011": "N",
    "110100": "O",
    "110101": "P",
    "110110": "Q",
    "110111": "R",
    "111000": "S",
    "111001": "T",
    "111010": "U",
    "111011": "V",
    "111100": "W",
    "111101": "X",
    "111110": "Y",
    "111111": "Z",
}
decode_b64={}
for i in b64:
    temp = {b64[i]: i}
    decode_b64.update(temp)
def decode(ciphertext):
    bin_string = ''
    for c in ciphertext:
        if c == '=':
            bin_string += ''
        else:
            bin_string += decode_b64[c]
    
    plaintext = ''
    for i in range(0, len(bin_string), 8):
        plaintext += chr(int(bin_string[i:i+8],2))
    
    print(plaintext)
decode('gOP+sRaKphbtmRjNr1+HlObgkl+Oa5R=')
```
Flag: KMA{s0m3_cust0m_CRYpt0}
